**使用反射生成并操作对象**
&emsp;&emsp;Class对象可以获得该类里的方法（Method），构造器（Constructor）、成员变量（Field），这三个都位于java.lang.reflect包下，并实现了java.lang.reflect.Member接口。程序可以通过Method对象来执行对应的方法，通过Constructor对象来调用对应的构造器创建实例。能通过Field对象直接访问并修改对象的成员变量值。  

**创建对象**  
- 使用Class对象的newInstance()方法来创建该Class对象对应类的实例，这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时，实际上是利用默认构造器来创建该类的实例。  
- 使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以使用指定的构造器来创建实例。

很多的java EE框架都需要根据配置文件信息来创建java对象，从配置文件读取的只是某个类的字符串类名，程序需要根据该字符串来创建对应的实例， 就必须使用反射。  

**demo**
```java
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

public class ObjectPoolFactory {
    private Map<String, Object> objectPool = new HashMap<>();

    private Object createObject(String clazzName) throws IllegalAccessException, ClassNotFoundException, InstantiationException {
        Class<?> clazz = Class.forName(clazzName);
        Object t = clazz.newInstance();
        return t;
    }

    public void initPool(String ... classNames) throws IllegalAccessException, ClassNotFoundException, InstantiationException {
//        try(
//                FileInputStream fis = new FileInputStream(fileName))
//        {
//            Properties props = new Properties();
//            props.load(fis);
            for (String name:classNames
                 ) {
                objectPool.put(name,createObject(name));
            }
//        }catch (IOException e){
//            e.printStackTrace();
//        }
    }

    public Object getObject(String name){
        return this.objectPool.get(name);
    }

    public static void main(String[] args) throws Exception{
        ObjectPoolFactory pf = new ObjectPoolFactory();
        pf.initPool("java.util.HashMap","java.util.Properties");
        System.out.println(pf.getObject("java.util.HashMap").getClass());
        System.out.println(pf.getObject("java.util.Properties").getClass());
    }
}

```


